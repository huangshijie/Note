# Access Control Modifier

default

pubic

protected

private

## Non-access control modifier

### final

final本身的含义是“最终的，不可改变的”，它可以修饰抽象类，非抽象方法和变量。 

不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。

```java
final String s = "sss"; //这边final修饰的是引用类型s
s = "222"; // 这样的赋值，编译器会报错，s无法指向新的对象。
```

**引用类型指向的对象的状态**有三种，主要是和垃圾回收机制相关的

- 可触及态：从根节点开始，可以搜索到这个对象，也就是可以访问到这个对象，也有人将其称为可达状态。(有些GC算法，就是通过这点来判断对象是否要被回收)
- 可复活态：从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，
但是该对象有可能在finalize()方法中再次被引用，从而复活。
- 不可触及态：对象的所有引用都被释放了，并且在对象的finalize()方法中没有复活，这样的话该对象就是不可触及状态。

#### final类

继承关系最大的弊端是破坏封装：子类能访问父类的实现细节，而且可以通过方法覆盖的形式修改实现细节。

表示最终类，该类不能在有子类，比如八大基本数据类型保证类和String等
> 只要满足以下条件就可以把一个类设计成final类
> 1. 某个类不是专门为继承而设计的
> 2. 处于安全考虑，类的实现细节不许改动
> 3. 确信该类不会再被扩展

#### final方法

子类可以调用，但是不能覆盖
> 构造方法不能使用final修饰，因为构造方法不能被继承，肯定是最终的。

#### final变量

final修饰基本类型变量：表示该变量的值不能改变，即不能重新赋值。

final修饰引用类型：表示该变量的引用地址不能改变，而不是引用地址里的内容不能变。即，如果常量是一个对象，那么不变的是对象引用，对象本身是可变的。

final是唯一可以修饰局部变量的修饰符，局部内部类只能访问final修饰的局部变量。

1. 表示常量，只能赋值一次，不能再次赋值
2. final变量必须显示的指定初始值，系统不会为final字段初始化

```word
为什么有些方法会被定义成final？
1. 能被子类调用，但是不能被子类覆盖
2. 可以提高运行效率


为什么Java匿名内部类中方法参数必须定义成final？

```

#### 为什么String类被设计成final？

首先String这个类中，有个私有属性

```java
private final char value[];
```

这个属性就是关键属性，存储了字符串中的值，正是因为这个值被设为final，所以说在创建完一个String对象之后，不能再改变他的状态，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。

##### 字符串常量池

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = "Hel" + "lo";
String s4 = "Hel" + new String("lo");
String s5 = new String("Hello");
String s6 = s5.intern();
String s7 = "H";
String s8 = "ello";
String s9 = s7 + s8;

System.out.println(s1 == s2);  // true
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
System.out.println(s1 == s9);  // false
System.out.println(s4 == s5);  // false
System.out.println(s1 == s6);  // true
```

s1在创建对象的同时，在字符串池中也创建了其对象的引用。

由于s2也是利用字面量创建，所以会先去字符串池中寻找是否有相等的字符串，显然s1已经帮他创建好了，它可以直接使用其引用。那么s1和s2所指向的都是同一个地址，所以s1==s2。

s3是一个字符串拼接操作，参与拼接的部分都是字面量，编译器会进行优化，在编译时s3就变成“Hello”了，所以s1==s3。

s4虽然也是拼接，但“lo”是通过new关键字创建的，在编译期无法知道它的地址，所以不能像s3一样优化。所以必须要等到运行时才能确定，必然新对象的地址和前面的不同。

同理，s9由两个变量拼接，编译期也不知道他们的具体位置，不会做出优化。

s5是new出来的，在堆中的地址肯定和s4不同。

s6利用intern()方法得到了s5在字符串池的引用，并不是s5本身的地址。由于它们在字符串池的引用都指向同一个“Hello”对象，自然s1==s6。

**总结一下：**
字面量创建字符串会先在字符串池中找，看是否有相等的对象，没有的话就在堆中创建，把地址驻留在字符串池；有的话则直接用池中的引用，避免重复创建对象。
new关键字创建时，前面的操作和字面量创建一样，只不过最后在运行时会创建一个新对象，变量所引用的都是这个新对象的地址。

```java
String str1 = new String("A"+"B") ; 会创建多少个对象? 
String str2 = new String("ABC") + "ABC" ; 会创建多少个对象?

str1：
字符串常量池："A","B","AB" : 3个
堆：new String("AB") ：1个
引用： str1 ：1个
总共 ： 5个

str2 ：
字符串常量池："ABC" : 1个
堆：new String("ABC") ：1个
引用： str2 ：1个
总共 ： 3个
```

##### intern

如果常量池中存在当前字符串，就会直接返回当前字符串；如果常量池中没有此字符串，会将此字符串放入常量池中后，再返回

不要和运行时常量池搞混

instanceof

https://www.zhihu.com/question/31203609/answer/576030121